from os.path import exists
from lxml import etree
from typing import Any, Optional
from tqdm import tqdm

from django.core.management.base import BaseCommand, CommandError, CommandParser
from django.utils import timezone

from profile_scraper.models import (
    Profile, BusinessInfo, Post, Hashtag, Location)


class Command(BaseCommand):
    help = "Download stored from database or upload existing posts to \
        database from xml file that was generated by APIFY"

    def add_arguments(self, parser: CommandParser) -> None:
        parser.add_argument('mode', type=str, choices=['download', 'upload'])
        group = parser.add_mutually_exclusive_group()
        group.add_argument('-L', '--location-based', type=str,
                           help='Specify path to xml-file with posts that \
                            were scraped by locations',)
        group.add_argument('-H', '--hashtag-based', type=str,
                           help='Specify path to xml-file with posts that \
                            were scraped by hashtags',)

    def handle(self, *args: Any, **options: Any) -> Optional[str]:
        mode = options['mode']
        if mode == 'upload':
            if load_path := options['location_based']:
                self._load_location_based(load_path)
            elif load_path := options['hashtag_based']:
                self._load_hashtag_based(load_path)
        else:
            raise CommandError(
                self.style.ERROR('Sorry, only upload functionality is implemented.'),)

    def _load_hashtag_based(self, path: str) -> None:
        pass

    def _load_location_based(self, path: str) -> None:
        root = self._get_root(path)

        # 1. Parse locations fisrt, because we need instagram-generated slugs
        city_info_tag = 'city_info'
        location_list_tag = 'location_list'
        location_tags = ['id', 'name', 'slug']
        data = [
            *zip(*[root.xpath(f'//item/{city_info_tag}/{tag}/text()')
                   for tag in location_tags]),
            *zip(*[root.xpath(f'//item/{location_list_tag}/{tag}/text()')
                   for tag in location_tags]),]
        locations = [dict(zip(location_tags, part)) for part in data]

        # 2. Parse posts while saving all objects
        post_tags = ['id', 'caption', 'hashtags', 'commentsCount',
                     'likesCount', 'timestamp', 'locationId',
                     'ownerUsername', 'ownerId', 'isSponsored']
        for item in tqdm(root.findall('item'), ncols=100, unit='element', colour='green'):
            data = [item.xpath(f'{tag}/text()') for tag in post_tags]
            post = dict(zip(post_tags, [part[0] if len(
                part) == 1 else part for part in data]))

            if not self._validate_post_data(post):
                continue

            message = f"Post with ext. id {post['id']} is being updated with:"

            # post
            post_obj, _ = Post.objects.get_or_create(
                external_id=post['id'],
                owner_username=post['ownerUsername'],
                likes_count=post['likesCount'],
                comments_count=post['commentsCount'],
                caption=post['caption'],
                timestamp=post['timestamp'],
                is_sponsored=(post['isSponsored'] == 'true'),)

            # profile
            profile_obj, _ = Profile.objects.get_or_create(
                external_id=post['ownerId'],
                username=post['ownerUsername'],)
            if post_obj.profile_id and post_obj.profile_id != profile_obj.id:
                message += " profile"
            post_obj.profile = profile_obj

            # location, do not create location without slug
            location = next(
                (location for location in locations
                 if location['id'] == post['locationId']), None,)
            if location:
                location_obj, _ = Location.objects.get_or_create(
                    external_id=location['id'],
                    name=location['name'],
                    slug=location['slug'],)
                if post_obj.location_id and post_obj.location_id != location_obj.id:
                    message += " location"
                post_obj.location = location_obj

            # hashtags
            Hashtag.objects.bulk_create(
                [Hashtag(title=hashtag)
                 for hashtag in post['hashtags']],
                 ignore_conflicts=True,)
            hashtag_objs = Hashtag.objects.filter(title__in=post['hashtags'])
            post_obj.hashtags.add(*hashtag_objs)

            if not message.endswith(':'):
                self.stdout.write(self.style.WARNING(message))

            post_obj.save()

    def _get_root(self, path) -> etree.Element:
        if not path or not exists(path):
            raise CommandError(self.style.ERROR("File path does not exist"))
        return etree.parse(path).getroot()

    def _validate_post_data(self, post: dict) -> bool:
        return all([post['id'],
                    post['ownerUsername'], post['timestamp'],
                    post['commentsCount'], post['likesCount']])
